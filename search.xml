<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈递归]]></title>
    <url>%2Fzh%2Fposts%2FAbout-Recursion%2F</url>
    <content type="text"><![CDATA[浅谈递归递归是指在编程中函数在函数体中调用自身的过程，体现的是分而治之的思想。 用一张图来说明： 从与循环的关系看递归从这个角度看，递归可以分为两种。 可以直接改写成循环的 改写成循环的时候需要用到栈的 第一种情况的例子有用于求最大公约数的辗转相除算法，还有求斐波那契数列第 n 项的算法，二分查找等： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 递归式辗转相除算法public class Recursion &#123; public static int gcd(int either, int other) &#123; if (other == 0) &#123; return either; &#125; return gcd(other, either % other) &#125;&#125;// 循环式辗转相除算法public class Iteration &#123; public static int gcd(int either, int other) &#123; while (other != 0) &#123; int remainder = either % other; either = other; other = remainder; &#125; &#125;&#125;// 递归式斐波那契算法public class Recursion &#123; public static int fibonacci(int number) &#123; if (number == 0 || number == 1) &#123; return number; &#125; return fibonacci(number - 1) + fibonacci(number - 2); &#125;&#125;// 尾递归式斐波那契算法public class TailRecursion &#123; public static int fibonacci(int number) &#123; return fibonacci(0, 1, number); &#125; private static int fibonacci(int current, int next, int number) &#123; if (number == 0) &#123; return current; &#125; if (number == 1) &#123; return next; &#125; return fibonacci(next, current + next, number--); &#125;&#125;// 循环式斐波那契算法public class Iteration &#123; public static int fibonacci(int number) &#123; int current = 0; int next = 1; for (int i = 0; i &lt; number; i++) &#123; int temporary = current + next; current = next; next = temporary; &#125; return current; &#125;&#125; 通过上面的代码可以看到，这一类的递归和循环之间存在着比较直接的对应关系，改写成循环不需要借助任何辅助数据结构，并且改写成循环之后还有可能降低开销甚至时间复杂度。例如：求斐波那契数列第 n 项的算法的递归形式的时间复杂的是惊人的 $O(2^n)$，而对应的循环形式的时间复杂度是 $O(n)$。 第二种情况的例子有二叉树的遍历等： 1234567891011121314151617181920212223242526272829303132333435363738394041// 这里以二叉树的中序遍历为例// 二叉树节点public class Node&lt;Item&gt; &#123; Item item; Node&lt;Item&gt; left; Node&lt;Item&gt; right;&#125;// 递归式二叉树中序遍历public class Recursion &#123; public static void traverse(Node&lt;Item&gt; root) &#123; if (root == null) &#123; return; &#125; traverse(root.left); System.out.println(root.item); traverse(root.right); &#125;&#125;// 循环式二叉树中序遍历public class Iteration &#123; public static void traverse(Node&lt;Item&gt; root) &#123; Stack&lt;Node&lt;Item&gt;&gt; stack = new Stack(); Node&lt;Item&gt; node = root; while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.left(); &#125; node = stack.pop(); System.out.println(node.item); node = node.right(); &#125; &#125;&#125; 通过上面的代码可以看到，这一类递归若要改写成循环需要借助栈的帮助，就此例而言时间复杂度没有变化，都为 $O(n)$。 如何区分这两种递归尾递归在具体讨论如何区分这两种递归之前，我们先来了解一个已有的定义：尾递归 在具体讨论尾递归之前，我们先来了解一下另一个已有的定义：尾调用 尾调用是指：一个函数里的最后一个动作是返回一个函数调用的情形。例如： 1234567891011121314151617181920212223int g() &#123; // ... return 0;&#125;// 函数 f 中最后一个动作是返回对函数 g 的调用，这就称之为尾调用int f() &#123; // ... return g();&#125;// 函数 h 最后一个动作不是返回对函数 g 的调用，而是返回对函数 g 的调用结果再加 1，这就不是尾调用了int h() &#123; // ... return g() + 1;&#125;// 函数 i 可以改写成函数 f，但函数 i 不能算是严格意义上的尾调用int i() &#123; // ... int g = g(); return g;&#125; 而尾递归就是尾调用的的特例，尾递归函数中最后一个动作是返回对该函数自身的调用。上文中，辗转相除算法的递归形式就是尾递归的例子。而尾递归属于第一类递归，即可以直接改写为循环，不需要栈的辅助。而很多现代的编译期甚至会直接对尾递归进行优化，消除调用过程中的栈帧，这样就再也不会 StackOverflow 啦。 递归函数的执行过程为了了解为什么递归会分成这两种以及为什么尾递归属于第一类递归，我们先来分析递归函数的执行过程。 对于任何递归函数，其执行流程都可以看成两部分： 向下调用 向下调用是指：从递归函数执行开始，其不断向下调用自身，直到遇到第一个返回语句的整个过程。 向上返回 向上返回是指：从遇到的第一个返回语句开始，其不断的向上返回，直到返回到最顶层，或在返回途中再次遇到对自身的调用的整个过程。 以辗转相除算法的递归函数为例，其执行过程如下图所示： 剩下的明天再更😂]]></content>
      <categories>
        <category>编程</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个算法与数据结构库（一）]]></title>
    <url>%2Fzh%2Fposts%2FProject-Algorithms-I%2F</url>
    <content type="text"><![CDATA[动机 动机一：学习了普林斯顿大学 Robert Sedgewick 教授的算法公开课之后想要更加深入的学习。 动机二：读了 Java 的 Collections 框架的部分源代码后，希望能在此基础上做的更好。 动机三：产生了一种有助于降低代码耦合度，提升灵活性和复用程度的设计思路，想要验证这种思路。 基于以上三点，我决定重构在学习算法公开课的时候用于练习的算法库。 计划目前还处于前期开发状态，待 API 稳定后，将会以专栏文章的形式解析其设计思路，实现过程及源代码，并和现有实现进行对比分析。目前正在开发中的主要是容器（对标 Java 的集合类）。 以《算法，第四版》和 Collections 框架为基础； 在实现上尽量保证效率（时间和空间复杂度）和正确性，同时追求代码可读性，一致性，可维护性和高复用度； 充分利用语言特性，保证类型安全，异常安全等。 目录 博客搭好这么久却一直没时间更新，今天先挖坑，就当是对自己的督促吧。]]></content>
      <categories>
        <category>项目</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，世界]]></title>
    <url>%2Fzh%2Fposts%2FHello-World%2F</url>
    <content type="text"><![CDATA[你好，世界终于搭建好属于自己的博客啦！ 主要分享技术和思想，偶尔聊聊其他。😂 栏目简介： 点子： 灵感分享 书籍： 书籍推荐 课程： 课程搜罗 1234567// Javaclass HelloWorld &#123; public static void main() &#123; System.out.println("Hello World!"); &#125;&#125; 1234567// C++#include "iostream"int main() &#123; std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl; return 0;&#125; 1234567// C#include "stdio.h"int main() &#123; printf("Hello World!\n"); return 0;&#125; 12# Pythonprint("Hello World!") 12// JavaScriptConsole.log("Hello World!");]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fzh%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[热爱计算机热爱互联网热爱人工智能 极客完美主义者兴趣和好奇心驱动 保持饥饿，保持愚蠢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[书籍]]></title>
    <url>%2Fzh%2Fbooks%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fzh%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[课程]]></title>
    <url>%2Fzh%2Fcourses%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[点子]]></title>
    <url>%2Fzh%2Fideas%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Fzh%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
