<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Paxos Made Simple 翻译及总结]]></title>
    <url>%2Fzh%2Fposts%2FPaxos-Made-Simple-Reading%2F</url>
    <content type="text"><![CDATA[Paxos Made Simple 翻译及总结 ¶ Warm-up / 预热 The Paxos algorithm, when presented in plain English, is very simple. Paxos Made Simple, by Leslie Lamport The Fast Paxos algorithm, when presented in plain English, is still quite hard to understand for those like us — people who don’t have the brain of Leslie Lamport. A Simpler Proof for Paxos and Fast Paxos, by Keith Marzullo, Alessandro Mei and Hein Meling 😂 ¶ The Problem / 问题 Safety requirements for consensus / 一致性算法的基本要求: 1 / 约束1: Only a value that has been proposed may be chosen / 只能通过已经被提出的值 2 / 约束2: Only a single value is chosen / 只能通过单个值 3 / 约束3: A process never learns that a value has been chosen unless it actually has been / 只能了解已经被通过的值 Roles / 角色 Proposers / 议长，发起议案 Acceptors / 议员，赞成议案 Learners / 听众，了解议案 A single process may act as more than one agent / 允许身兼数职 Asynchronous, non-Byzantine model / 异步，非拜占庭模型: Asynchronous / 异步: Agents operate at arbitrary speed, may fail by stopping, and may restart. Since all agents may fail after a value is chosen and then restart, a solution is impossible unless some information can be remembered by an agent that has failed and restarted. / 代理以任意速度运行，可能失效，也可能重启。由于可能出现在通过一个值以后全部代理都失效，所以代理失效前需要保存一些必要的信息，否则将无法恢复。 Non-Byzantine / 非拜占庭: Messages can take arbitrarily long to be delivered, can be duplicated, and can be lost, but they are not corrupted. / 消息可能耗费任意长的时间送达，可能重复，也可能丢失，但是不会出错（保证发送的消息和接收到的消息一致）。 ¶ Choosing a Value / 值的通过 ¶ Single acceptor agent / 单个议员 A proposer sends a proposal to the acceptor, who chooses the first proposed value that it receives. / 议长向议员发送一份议案，议员通过最开始接收到的议案。 Simple but unsatisfactory, because the failure of the acceptor makes any further progress impossible. / 简单但是还不够好，因为议员一旦失效，整个系统也随之失效。 ¶ Multiple acceptor agents / 多个议员 A proposer sends a proposed value to a set of acceptors. An acceptor may accept the proposed value. The value is chosen when a large enough set of acceptors have accepted it. How large is large enough? To ensure that only a single value is chosen, we can let a large enough set consist of any majority of the agents. Because any two majorities have at least one acceptor in common, this works if an acceptor can accept at most one value. / 一个议长将一份议案发送给一组议员。一个议员可能赞成该议案，也可能不赞成。当足够多的议员赞成了该议案，那么该议案就将通过。具体要多少议员赞成才是足够多？为了保证只有单个议案被通过，我们必须保证这一组议员包含全体议员中的多数议员*，因为任何两组多数议员至少会包含一位共有议员，如果一位议员只能赞成一个提案的话，那么就能保证只有单个议案被通过。 Majority / 多数: Majority means that a set is consisted of more than half of all acceptors / 多数表示这一组议员由全体议员的一半以上**的议员组成。 In the absence of failure or message loss, we want a value to be chosen even if only one value is proposed by a single proposer. / 在没有失效和信息丢失的情况下，如果只有一位议长，并且只提了一份议案，那么这个议案就应该被通过（否则系统将不能正常运行下去）。 P1 / 约束 P1: An acceptor must accept the first proposal that it receives. / 一位议员必须赞成其收到的第一份议案。 But this requirement raises a problem. Several values could be proposed by different proposers at about the same time, leading to a situation in which every acceptor has accepted a value, but no single value is accepted by a majority of them. Even with just two proposed values, if each is accepted by about half the acceptors, failure of a single acceptor could make it impossible to learn which of the values was chosen. / 但是约束 P1 还不够完备。不同的议长可能会同时发起多个不同的议案，可能导致不同的议员赞成了不同的议案，但是没有议案获得了多数议员的赞成。假设有两个议案，每个都获得了大约半数议员的赞同，如果议员总数为偶数个，系统将直接陷入死锁；如果议员总数为奇数个，那么最终决定权就落在了单个议员的手里，如果这时候该议员失效，那么系统就将陷入死锁。 上面的翻译我综合了自己的理解，可能和原文有些对应不上。 P1 and the requirement that a value is chosen only when it is accepted by a majority of acceptors imply that an acceptor must be allowed to accept more than one proposal. / 约束 P1 和约束当一份议案被多数议员赞成后才会被通过隐含了条件一位议员必须可以赞成不止一份议案。（反证法） We keep track of the different proposals that an acceptor may accept by assigning a (natural) number to each proposal, so a proposal consists of a proposal number and a value. To prevent confusion, we require that different proposals have different numbers. / 现在我们给议案分配一个自然数，所以现在一份议案是一个二元组（议案序号，值）。同时，为了唯一确定每一份议案，我们规定每一份议案的序号确定且唯一，并且议案的序号必须满足全序关系（全序关系即集合$X$上的反对称（若 $a \le b$ 且 $b \le a$ 则 $a = b$）的、传递（若 $a \le b$ 且 $b \le c$ 则 $a \le c$）的和完全（$a \le b$ 或 $b \le a$）的二元关系，简而言之，集合内的任意两个元素可以比较大小，计算机中的整型就满足全序关系，而 IEEE 754 定义的浮点数中，由于 $NaN \not\le NaN$，所以 IEEE 754 不满足全序关系）。 A value is chosen when a single proposal with that value has been accepted by a majority of the acceptors. In that case, we say that the proposal (as well as its value) has been chosen. / 当一份包含值 v 的议案被多数议员赞成的时候，我们就说该议案（也包括值 v） 被通过了。 We can allow multiple proposals to be chosen, but we must guarantee that all chosen proposals have the same value. / 现在我们可以通过多个议案了，但是我们必须确保通过的多个议案都包含相同的值，这样才能保证约束2。 P2 / 约束 P2: If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v. / 如果一份包含值 v 的议案已被通过，那么每一份大序号更大的议案都应该包含值 v。 Since numbers are totally ordered, condition P2 guarantees the crucial safety property that only a single value is chosen. / 由于议案序号满足全序关系，所以约束 P2 能保证约束 2。 To be chosen, a proposal must be accepted by at least one acceptor. / 一份议案要被通过，那么这份议案至少要被一位议员赞成。 So, we can satisfy P2 by satisfying / 所以，我们可以对约束 P2 进行加强： P2a / 约束 P2a: If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v. / 如果一份包含值 v 的议案已被通过，那么每一份被任何议员赞成的序号更大的议案也包含值 v。 We still maintain P1 to ensure that some proposal is chosen. / 此时，我们仍然需要保证约束 P1，以确保有议案被通过。 Because communication is asynchronous, a proposal could be chosen with some particular acceptor c never having received any proposal. Suppose a new proposer “wakes up” and issues a higher-numbered proposal with a different value. P1 requires c to accept this proposal, violating P2a. / 但是由于通讯是异步的，可能出现某些特定的议员，比如议员 c 完全没有参与某个议案的情况。然后，议长又发起了一份更大序号的并且包含不同的值的议案，这时，根据约束 P1 议员 c 应该赞成该议案，但是这种情况却违反了约束 P2a。 Maintaining both P1 and P2a requires strengthening P2a to / 所以我们在约束 P2a 的基础上继续增强约束: P2b / 约束 P2b: If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v. / 如果一份包含值 v 的议案已被通过，那么每一份被议长发起的序号更大的议案都包含值 v。 Since a proposal must be issued by a proposer before it can be accepted by an acceptor, P2b implies P2a, which in turn implies P2. / 由于一份议案在被议员赞成之前必须现有议案则发起，所以约束 P2b 蕴含约束 P2a，又因为约束 P2a 蕴含约束 P2，故约束 P2b 也蕴含约束 P2。 To discover how to satisfy P2b, let’s consider how we would prove that it holds. / 约束 P2b 虽然约束足够强，但是难以提出实现方式，所以我们通过证明约束 P2b 成立的方式来进一步加强约束。 We would assume that some proposal with number m and value v is chosen and show that any proposal issued with number n &gt; m also has value v. / 假设一份序号为 m 值为 v 的议案 (m, v) 已经被通过，试证任何已发起的序号为 n 且 n &gt; m 的议案都包含值 v。 We would make the proof easier by using induction on n, so we can prove that proposal number n has value v under the additional assumption that every proposal issued with a number in m . . (n − 1) has value v , where i . . j denotes the set of numbers from i through j . / 为了简化证明过程，我们对 n 使用数学归纳法，这样我们就可以通过附加假设条件每一份以及发起的序号在 m 到 n-1 这个闭区间的议案都包含值 v 来证明序号为 n 的议案包含值 v。 For the proposal numbered m to be chosen, there must be some set C consisting of a majority of acceptors such that every acceptor in C accepted it. / 对于将要被通过的序号为 m 的议案，一定存在一个集合 C 由多数议员构成，并且集合 C 中的所有议员都赞成了该议案。 Combining this with the induction assumption, the hypothesis that m is chosen implies / 再结合刚才的归纳假设，假设 m 已被通过则意味着: Every acceptor in C has accepted a proposal with number in m ..(n − 1), and every proposal with number in m ..(n − 1) accepted by any acceptor has value v. / 集合 C 中的每一位议员都接受了序号在 m 到 n-1 这个闭区间中的某个提议，并且每个序号在 m 到 n-1 这个闭区间中的提议都被包含值 v 的任意一位议员接受了。 Since any set S consisting of a majority of acceptors contains at least one member of C, we can conclude that a proposal numbered n has value v by ensuring that the following invariant is maintained / 回顾前面对于‘多数’议员的定义，由于任意由多数议员组成的集合 S 和集合 C 之间至少有一位共同议员，那么我们通过保证以下的不变性来得出序号为 n 的议案包含值 v 的结论: P2c / 约束 P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S. / 对于任意的 v 和 n，如果一份值为 v 序号为 n 的议案被发起，那么就存在一个由多数议员构成的集合 S 满足下列条件之一：(a) 集合 S 中没有任何一个议员赞成了任何序号小于 n 的议案；(b) v 是集合 S 中的议员所赞成的所有序号小于 n 的议案中序号最大的那一份议案所包含的值。 结合 P2c 的假设和条件 (b) 可以证明 P2c 蕴含了 P2b To maintain the invariance of P2c, a proposer that wants to issue a proposal numbered n must learn the highest-numbered proposal with number less than n, if any, that has been or will be accepted by each acceptor in some majority of acceptors. / 为了维持约束 P2c 的不变性，当一位议长想发起一份值为 n 的议案之前，如果存在序号小于 n 的的议案的话，他必须先知道其中已经或者将要被多数议员赞成的序号最大的那一份议案。 Learning about proposals already accepted is easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there won’t be any such acceptances. In other words, the proposer requests that the acceptors not accept any more proposals numbered less than n. / 相对于预测将来的议员赞成情况而言，了解已经被议员赞成的议案要简单得多。因此，与其花大力气去预测未来，还不如通过承诺的方式来让议长控制不会有不符合条件的议案赞成情况。换句话说，议长要求议员作出承诺，保证不会再赞成序号小于 n 的议案。 This leads to the following algorithm for issuing proposals. / 这样，我们就得到了发起议案的算法: A proposer chooses a new proposal number n and sends a request to each member of some set of acceptors, asking it to respond with / 一位议长通过一个新的议案序号 n，然后向某个集合（应该是‘多数’议员）的全部议员发起请求，并要求对方回复以下两方面的内容: (a) A promise never again to accept a proposal numbered less than n, and / 要求对方作出承诺，保证不再赞成任何序号小于 n 的议案 (b) The proposal with the highest number less than n that it has accepted, if any. / 已经赞成的序号小于 n 的议案中，序号最大的那一份议案 I will call such a request a prepare request with number n. / 我们将这个过程称作序号 n 的准备请求 If the proposer receives the requested responses from a majority of the acceptors, then it can issue a proposal with number n and value v, where v is the value of the highest-numbered proposal among the responses, or is any value selected by the proposer if the responders reported no proposals. / 如果议长收到了多数议员的回复，那么他才能够发起序号为 n 值为 v 的议案，其中 v 是收到的回复中的所有议案里序号最大的那一份议案的值，如果所有回复中都不包含议案，那么 v 则由议长自行指定。 A proposer issues a proposal by sending, to some set of acceptors, a request that the proposal be accepted. (This need not be the same set of acceptors that responded to the initial requests.), Let’s call this an accept request. / 最后，议长将确定好的议案作为请求发送给一组议员（这里的这一组议员不能和初始阶段的一样），我们将这个过程称为赞成请求。 What about an acceptor? It can receive two kinds of requests from proposers: prepare requests and accept requests. An acceptor can ignore any request without compromising safety. / 对于议员而言，其可以接收两种来自议长的请求：准备请求和赞成请求。并且议员会忽略掉那些不满足约束的请求。 So, we need to say only when it is allowed to respond to a request. It can always respond to a prepare request. It can respond to an accept request, accepting the proposal, iff it has not promised not to. In other words / 所以，对于准备请求而言，议员总是可以响应；对于赞成请求而言，当且仅当该议员没有承诺过不赞成该请求时，才响应。换句话说 : P1a / 约束 P1a: An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n. / 当且仅当一位议员没有响应过序号大于 n 的准备请求时，该议员才能赞成序号为 n 的议案。 Observe that P1a subsumes P1. / 通过观察可以发现约束 P1a 蕴含 P1。 We now have a complete algorithm for choosing a value that satisfies the required safety properties—assuming unique proposal numbers. The final algorithm is obtained by making one small optimization. / 至此，在议案序号唯一的前提下，我们通过推导得到了完整的通过值的算法。最终的算法还可以在此基础上做一些优化。 Suppose an acceptor receives a prepare request numbered n, but it has already responded to a prepare request numbered greater than n, thereby promising not to accept any new proposal numbered n. There is then no reason for the acceptor to respond to the new prepare request, since it will not accept the proposal numbered n that the proposer wants to issue. So we have the acceptor ignore such a prepare request. We also have it ignore a prepare request for a proposal it has already accepted. 在议员已经响应了一个序号大于 n 的准备请求以后，对于序号为 n 的准备请求就没有必要响应了。同时，对于已经赞成的议案，也没有必要再赞成第二次。 With this optimization, an acceptor needs to remember only the highest-numbered proposal that it has ever accepted and the number of the highest-numbered prepare request to which it has responded. Because P2c must be kept invariant regardless of failures, an acceptor must remember this information even if it fails and then restarts. / 经过上面的优化以后，议员只需要保存他赞成过的议案中序号最大的那一份和响应过得准备请求中序号最大的那一个就行。因为即使在有失效的情况下我们也必须维护约束 P2c 的不变性，议员就算经历失效或者重启也必须保存上面的信息。 Note that the proposer can always abandon a proposal and forget all about it—as long as it never tries to issue another proposal with the same number. / 值得注意的是，议长总是可以通过不再发起相同序号的新议案的方式来放弃并且遗忘调一份议案。 ¶ Conclude / 总结 Requirements for the algorithm / 算法的约束: 1 / 约束1: Only a value that has been proposed may be chosen / 只能通过已经被提出的值 2 / 约束2: Only a single value is chosen / 只能通过单个值 3 / 约束3: A process never learns that a value has been chosen unless it actually has been / 只能了解已经被通过的值 P1a / 约束 P1a: An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n. / 当且仅当一位议员没有响应过序号大于 n 的准备请求时，该议员才能赞成序号为 n 的议案。 P2c / 约束 P2c: For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S. / 对于任意的 v 和 n，如果一份值为 v 序号为 n 的议案被发起，那么就存在一个由多数议员构成的集合 S 满足下列条件之一：(a) 集合 S 中没有任何一个议员赞成了任何序号小于 n 的议案；(b) v 是集合 S 中的议员所赞成的所有序号小于 n 的议案中序号最大的那一份议案所包含的值。 Properties of the algorithm / 算法的特性: Immutability of value / 值的不可变性 要么集群中没有任何议案被提出，这时没有值，一旦有合法的议案被提出，无论后面有多少新的合法的议案被提出，值都是最开始的合法议案中的值。所以称值具有不可变性。 Minority obeying majority / 少数服从多数 多数定义是至少为全体的一半以上（不包括刚好一半）。 Prevent the occurrence, Instead of trying to predict the future / 与其预测未来，不如提前预防 要求议员在准备阶段作出承诺。 ¶ The Algorithm / 算法 Putting the actions of the proposer and acceptor together, we see that the algorithm operates in the following two phases. / 将上面的过程整合在一起，我们就得到了最终的算法（通过值部分）: Phase 1 / 阶段 1 (a) A proposer selects a proposal number n and sends a prepare request with number n to a majority of acceptors. / 一位议长通过一份议案序号 n，并向多数议员发送序号为 n 的准备请求。 (b) If an acceptor receives a prepare request with number n greater than that of any prepare request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted. / 如果一位议员接收到的序号为 n 的准备请求的序号大于了任何已经响应的准备请求，那么该议员将响应接收到的序号为 n 的准备请求，作出承诺不再赞成任何序号小于 n 的，并且，如果已经赞成过任何议案的话，顺便返回其中序号最大的那一个（同发起议案算法第1点）。 Phase 2 / 阶段 2 (a) If the proposer receives a response to its prepare requests (numbered n) from a majority of acceptors, then it sends an accept request to each of those acceptors for a proposal numbered n with a value v, where v is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals. / 如果议长收到了多数议员对序号为 n 的准备请求的响应，那么议长就开始向另一组多数议员中的每一位发送序号为 n 值为 v 的议案，其中 v 是收到的响应中的议案中序号最大的那一份议案所包含的值，如果收到的响应中不包含任何议案，那么值 v 由议长任意指定。 (b) If an acceptor receives an accept request for a proposal numbered n, it accepts the proposal unless it has already responded to a prepare request having a number greater than n. / 如果一位议员收到序号为 n 的赞成请求，在没有响应过序号大于 n 的准备请求的情况下，该议员将赞成此议案。 A proposer can make multiple proposals, so long as it follows the algorithm for each one. / 议长可以发起多个议案，前提是每一份议案都需要按照算法的流程进行。 It can abandon a proposal in the middle of the protocol at any time. (Correctness is maintained, even though requests and/or responses for the proposal may arrive at their destinations long after the proposal was abandoned.) / 议长可以在任何时候中途废弃议案。（尽管请求或者响应可能在到达目的地之前就已经被废弃，但正确性依然不会受到影响。） It is probably a good idea to abandon a proposal if some proposer has begun trying to issue a higher-numbered one. / 在某个议长尝试发起一个序号更大的议案时，废弃已有的议案可能是个不错的想法。 Therefore, if an acceptor ignores a prepare or accept request because it has already received a prepare request with a higher number, then it should probably inform the proposer, who should then abandon its proposal. This is a performance optimization that does not affect correctness. / 因此，在一位议员因为已经接收到了更大序号的准备请求后，而忽略当前准备或者赞成请求的时候，该议员应该通知相应的议长废弃当前议案。这在不影响正确性的情况下提高了性能。 ¶ Learning a Chosen Value / 了解已通过的值 To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. The obvious algorithm is to have each acceptor, whenever it accepts a proposal, respond to all learners, sending them the proposal. This allows learners to find out about a chosen value as soon as possible, but it requires each acceptor to respond to each learner—a number of responses equal to the product of the number of acceptors and the number of learners. / 为了使听众了解已经被通过的值，听众必须得知道被多数议员赞成的议案的内容。最直观的算法就是，每当议员赞成某个提案时，就通知所有的听众，向他们发送该议案。这样可以保证及时性，但是复杂度太高，达到了 $O(n * m)​$ ，这里 n 是议员个数，m 是听众个数。 The assumption of non-Byzantine failures makes it easy for one learner to find out from another learner that a value has been accepted. We can have the acceptors respond with their acceptances to a distinguished learner, which in turn informs the other learners when a value has been chosen. This approach requires an extra round for all the learners to discover the chosen value. It is also less reliable, since the distinguished learner could fail. But it requires a number of responses equal only to the sum of the number of acceptors and the number of learners. / 回顾前面的非拜占庭假设，我们发现听众可以通过其他听众来准确的了解已被赞成的议案。这样一来，议员就只需要通知某个特定的听众了，剩下的通知工作就可以由听众之间的相互传递来完成。于是，复杂度降低到了 $O(n + m)​$ 。但是，这样的话这位特定的听众就成了单点，会导致可靠性下降很多。 复杂度好像还可以更低，如果听众之间用 P2P 通信，应该可以降到 $O(n + log_2 m)​$ More generally, the acceptors could respond with their acceptances to some set of distinguished learners, each of which can then inform all the learners when a value has been chosen. Using a larger set of distinguished learners provides greater reliability at the cost of greater communication complexity. / 介于以上两种策略都有致命的缺陷，一种复杂度太高，另一种可靠性太低，于是我们取两者的折中方案。将第二种方法中的特定听众由一位扩展到一组。以此提高可靠性，但是会以复杂度的提升为代价，需要根据具体场景做权衡。 Because of message loss, a value could be chosen with no learner ever finding out. The learner could ask the acceptors what proposals they have accepted, but failure of an acceptor could make it impossible to know whether or not a majority had accepted a particular proposal. In that case, learners will find out what value is chosen only when a new proposal is chosen. If a learner needs to know whether a value has been chosen, it can have a proposer issue a proposal, using the algorithm described above. / 由于消息有可能会丢失，那么就可能出现一个值被通过了，却没有任何听众了解。听众可以主动询问议员已经赞成了什么议案，但是在极端情况（多数议员之间只有一个共同议员的情况）下，一位议员失效就将导致无法区分该议案是否获得了多数议员的赞成。在这种情况下，听众只能被动的在新的提案被通过的时候才能了解被多数议员赞成的值。如果听众需要主动获得当先被多数议员通过的值，那么他只能通过发起一次新的议案来达到目的，但这也要求该听众同时也是议长（身兼多职）。 ¶ The Progress / 过程 It’s easy to construct a scenario in which two proposers each keep issuing a sequence of proposals with increasing numbers, none of which are ever chosen. Proposer p completes phase 1 for a proposal number n1. Another proposer q then completes phase 1 for a proposal number n2 &gt; n1. Proposer p’s phase 2 accept requests for a proposal numbered n1 are ignored because the acceptors have all promised not to accept any new proposal numbered less than n2. So, proposer p then begins and completes phase 1 for a new proposal number n3 &gt; n2, causing the second phase 2 accept requests of proposer q to be ignored. And so on. / 即使对于上面的算法，仍然可以轻易的构造出两位议长交替发起序号更大的议案，但却无法最终确定的情况，称之为活锁。例如：议长 p 完成了序号为 n1 的阶段 1。另一位议长 q 然后完成了序号 n2 的阶段 1，并且 n2 &gt; n1。议长 p 的阶段 2 的赞成请求会由于议员响应了 议长 q 的 n2 的准备请求（保证不再赞成任何序号小于 n2 的议案）而被忽略。这样，议长 p 就会发起序号为 n3 的阶段 1，且 n3 &gt; n2，于是议长 q 的 序号为 n2 的议案的阶段 2 又会由于议员响应了 议长 p 的 n3 的准备请求（保证不再赞成任何序号小于 n3 的议案）而被忽略，以此循环往复，无休无止。 To guarantee progress, a distinguished proposer must be selected as the only one to try issuing proposals. If the distinguished proposer can communicate successfully with a majority of acceptors, and if it uses a proposal with number greater than any already used, then it will succeed in issuing a proposal that is accepted. By abandoning a proposal and trying again if it learns about some request with a higher proposal number, the distinguished proposer will eventually choose a high enough proposal number. / 为了保证流程的正常进行，避免活锁的情况，系统中必须只能有一位议长，并且作为唯一的议案发起者，当该议长能够正常的和多数议员通信并且使用大于任何已有议案的序号的议案序号，那么就能保证发起的议案被正常赞成。当该议长了解更大的序号时，废弃当前议案，并发起一份序号更大的议案，以此往复，最终就能发起一份序号足够大的议案，并获得赞成。 这样一来，这位集群中唯一的议长就成了单点，为了解决这个问题，需要一种选举算法，在这位议长失效或重启时，及时的选举出替代者，以保证集群正常运作。 值得注意的是，为了避免活锁，算法现在只允许集群中有一位议长，而不是最开始的多位议长了，并且增加了议长选举机制（可能是从议员或者听众之间选举，也可能是其他角色）。 If enough of the system (proposer, acceptors, and communication network) is working properly, liveness can therefore be achieved by electing a single distinguished proposer. / 如果有足够多的系统（单个议长，多位议员，以及通信网络）正常运行，集群的健康度就能通过议长的选举来保证。 ¶ Extension / 拓展 The Part-Time Parliament Paxos 算法的最初论文。 论文：The Part-Time Parliament, by Leslie Lamport Multi-Paxos Paxos 是对一个值达成一致，Multi-Paxos 是运行多个 Paxos 实例来对多个值达成一致，每个 Paxos 实例对不同的值达成一致。 论文：Multi-Paxos: An Implementation and Evaluation, by Hao Du and David J. St. Hilaire Fast-Paxos Paxos 的进一步工程化，就是 Client 的提案由 Coordinator 进行，Coordinator 存在多个，但只能通过其中被选定 Leader 进行；提案由 Leader 交由 Server (Acceptor) 进行表决，之后 Client 作为 Learner 学习决议的结果。这种方式更多地考虑了 Client / Server 这种通用架构，更清楚地注意到了 Client 既作为 Proposer 又作为 Learner 这一事实。 论文：Fast Paxos, by Leslie Lamport 论文：A Simpler Proof for Paxos and Fast Paxos, by by Keith Marzullo, Alessandro Mei and Hein Meling Raft Raft is a consensus algorithm that is designed to be easy to understand. It’s equivalent to Paxos in fault-tolerance and performance. The difference is that it’s decomposed into relatively independent subproblems, and it cleanly addresses all major pieces needed for practical systems. / Raft 算法被设计的更容易理解。在容错和性能方面与 Paxos 算法相当。 论文及实现：Raft Consensus Algorithm]]></content>
      <categories>
        <category>论文</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>一致性算法</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈递归]]></title>
    <url>%2Fzh%2Fposts%2FAbout-Recursion%2F</url>
    <content type="text"><![CDATA[浅谈递归 递归是指在编程中函数在函数体中调用自身的过程，体现的是分而治之的思想。 用一张图来说明： ¶ 从与循环的关系看递归 从这个角度看，递归可以分为两种。 可以直接改写成循环的，这里称为第一类递归。 改写成循环的时候需要用到栈的，这里称为第二类递归。 第一种情况的例子有用于求最大公约数的辗转相除算法，还有求斐波那契数列第 n 项的算法，二分查找等： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 递归式辗转相除算法public class Recursion &#123; public static int gcd(int either, int other) &#123; if (other == 0) &#123; return either; &#125; return gcd(other, either % other) &#125;&#125;// 循环式辗转相除算法public class Iteration &#123; public static int gcd(int either, int other) &#123; while (other != 0) &#123; int remainder = either % other; either = other; other = remainder; &#125; return either; &#125;&#125;// 递归式斐波那契算法public class Recursion &#123; public static int fibonacci(int number) &#123; if (number &lt; 2) &#123; return number; &#125; return fibonacci(number - 1) + fibonacci(number - 2); &#125;&#125;// 尾递归式斐波那契算法public class TailRecursion &#123; public static int fibonacci(int number) &#123; return fibonacci(0, 1, number); &#125; private static int fibonacci(int current, int next, int number) &#123; if (number &lt; 1) &#123; return current; &#125; if (number &lt; 2) &#123; return next; &#125; return fibonacci(next, current + next, number--); &#125;&#125;// 循环式斐波那契算法public class Iteration &#123; public static int fibonacci(int number) &#123; int current = 0; int next = 1; for (int i = 0; i &lt; number; i++) &#123; int temporary = current + next; current = next; next = temporary; &#125; return current; &#125;&#125; 通过上面的代码可以看到，这一类的递归和循环之间存在着比较直接的对应关系，改写成循环不需要借助任何辅助数据结构，并且改写成循环之后还有可能降低开销甚至时间复杂度。例如：求斐波那契数列第 n 项的算法的递归形式的时间复杂的是惊人的 $O(2^n)$，尾递归形式的时间复杂度是 $O(n)$，而对应的循环形式的时间复杂度也是 $O(n)$。 第二种情况的例子有二叉树的遍历等： 123456789101112131415161718192021222324252627282930313233343536373839404142// 这里以二叉树的中序遍历为例// 二叉树节点public class Node&lt;Item&gt; &#123; Item item; Node&lt;Item&gt; left; Node&lt;Item&gt; right;&#125;// 递归式二叉树中序遍历public class Recursion &#123; public static void traverse(Node&lt;Item&gt; root) &#123; if (root == null) &#123; return; &#125; traverse(root.left); System.out.println(root.item); traverse(root.right); &#125;&#125;// 循环式二叉树中序遍历public class Iteration &#123; public static void traverse(Node&lt;Item&gt; root) &#123; Stack&lt;Node&lt;Item&gt;&gt; stack = new Stack(); Node&lt;Item&gt; node = root; while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.left(); &#125; node = stack.pop(); System.out.println(node.item); node = node.right(); &#125; &#125;&#125; 通过上面的代码可以看到，这一类递归若要改写成循环需要借助栈的帮助，就此例而言时间复杂度没有变化，都为 $O(n)$。 ¶ 如何区分这两种递归 ¶ 尾递归 在具体讨论如何区分这两种递归之前，我们先来了解一个已有的定义：尾递归 在具体讨论尾递归之前，我们先来了解一下另一个已有的定义：尾调用 尾调用是指：一个函数里的最后一个动作是返回一个函数调用的情形。例如： 1234567891011121314151617181920212223int g() &#123; // ... return 0;&#125;// 函数 f 中最后一个动作是返回对函数 g 的调用，这就称之为尾调用int f() &#123; // ... return g();&#125;// 函数 h 最后一个动作不是返回对函数 g 的调用，而是返回对函数 g 的调用结果再加 1，这就不是尾调用了int h() &#123; // ... return g() + 1;&#125;// 函数 i 可以改写成函数 f，但函数 i 不能算是严格意义上的尾调用int i() &#123; // ... int g = g(); return g;&#125; 而尾递归就是尾调用的的特例，尾递归函数中最后一个动作是返回对该函数自身的调用。上文中，辗转相除算法的递归形式就是尾递归的例子。而尾递归属于第一类递归，即可以直接改写为循环，不需要栈的辅助。而很多现代的编译期甚至会直接对尾递归进行优化，消除调用过程中的栈帧，这样就再也不会 StackOverflow 啦。 ¶ 递归函数的执行过程 为了了解为什么递归会分成这两种以及为什么尾递归属于第一类递归，我们先来分析递归函数的执行过程。 对于任何递归函数，其执行流程都可以看成两部分： 向下调用 向下调用是指：函数调用自身这个过程。如果把递归函数的执行过程看成一颗以初始调用为根的树，向下调用会向下加大树的深度，也就是会增加栈帧。 向上返回 向上返回是指：函数调用执行完毕，结束自身并向调用方放回的过程。如果把递归函数的执行过程看成一颗以初始调用为根的树，向上返回会向上减小树的深度，也就是会减少栈帧。 以辗转相除算法的递归函数为例，其执行过程如下图所示： 再以二叉树的中序遍历递归函数为例，其递归调用过程如下： ¶ 观察 首先，我们来看辗转相除算法的递归调用过程，可以发现其具备以下特征： 递归调用过程单调，这里的单调是指该函数的执行过程是先连续的向下调用，紧接着连续的向上返回直至结束。 只在向下调用的过程中用到参数。 然后，我们来看二叉树的中序遍历的递归调用过程： 递归调用过程不单调，向下调用和向上返回交叉着进行。 在向下调用的过程中用到参数后并返回后，继续使用到了参数。 基于以上观察，我们了解到区分递归函数的关键可能与以下因素有关。 向上返回过程中是否用到参数。 递归调用过程是否单调。 ¶ 思考 ¶ 递归调用过程不单调 我们先来思考最显而易见的情形，当递归函数的调用过程不单调时，就如上文中提到的二叉树的中序遍历，由于每一层的递归调用的参数都有可能在接下来的调用过程中被再次用到，所以必须要把每一层的调用信息（包括参数，局部变量等）都存入栈中，以备在后面的调用过程中再次使用，所以，当递归调用过程不单调的时候，栈是必须的，因此该类递归属于第二类递归，即在改写为循环时需要使用到栈。 ¶ 递归调用过程单调 既然递归调用过程不单调属于第二类递归，那么是不是递归调用过程单调就属于第一类递归了呢？答案比想象中的要复杂，请看下面的分析： ¶ 尾递归 首先我们来看递归调用过程单调中最简单的情形——尾递归： 1234567891011121314151617181920212223// 递归式辗转相除算法public class Recursion &#123; public static int gcd(int either, int other) &#123; if (other == 0) &#123; return either; &#125; return gcd(other, either % other) &#125;&#125;// 循环式辗转相除算法public class Iteration &#123; public static int gcd(int either, int other) &#123; while (other != 0) &#123; int remainder = either % other; either = other; other = remainder; &#125; return either; &#125;&#125; 我们可以看到，尾递归函数的调用过程不仅单调，而且在连续向上返回的过程中除了向上层传递结果并没有额外操作，所有运算在连续向下调用的过程中就已完成，基于这种特点，我们可以认为其和循环直接等价。所以尾递归属于第一类循环，即改写为循环时无需使用栈。 ¶ 用到常数 现在我们在尾递归的基础上增加一些操作，在不改变其调用过程的单调性的前提下，在连续向上返回的这个过程中加入额外的运算： 12345678910111213141516171819202122232425262728293031// 下面的代码仅用于说明概念，其作用已经不再是辗转相除法求最大公约数// 递归public class Recursion &#123; private static final CONSTANT = 2; public static int gcd(int either, int other) &#123; if (other == 0) &#123; return either; &#125; return gcd(other, either % other) + CONSTANT; &#125;&#125;// 循环public class Iteration &#123; private static final CONSTANT = 2; public static int gcd(int either, int other) &#123; int sum = 0; while (other != 0) &#123; int remainder = either % other; either = other; other = remainder; sum += CONSTANT; &#125; return either + sum; &#125;&#125; 我们可以看到，虽然现在的递归函数已经不像尾递归那么“纯正”，但其仍然属于第一类递归。看来在向上返回的过程中加上和常数的操作并不能改变其性质。 ¶ 用到参数 既然加上和常数操作不能改变其性质，那么要是加上和变量的操作呢？递归函数里面的变量从哪里来呢？参数！嗯，所以我们现在来试试在不改变其调用过程的单调性的前提下，在向上返回的过程中加上对参数的操作： 123456789101112131415161718192021222324252627// 下面的代码仅用于说明概念，其作用已经不再是辗转相除法求最大公约数// 递归public class Recursion &#123; public static int gcd(int either, int other) &#123; if (other == 0) &#123; return either; &#125; return gcd(other, either % other) + other; &#125;&#125;// 循环public class Iteration &#123; public static int gcd(int either, int other) &#123; int sum = 0; while (other != 0) &#123; sum += other; int remainder = either % other; either = other; other = remainder; &#125; return either + sum; &#125;&#125; 什么？？？怎么还是可以在改写为循环的时候不用到栈？难道递归调用过程单调就能断定递归函数属于第一类递归吗？其实不然，请看下面的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 先序遍历二叉树最作边的路径上的全部节点// 二叉树节点public class Node&lt;Item&gt; &#123; Item item; Node&lt;Item&gt; left; Node&lt;Item&gt; right;&#125;// 递归式二叉树先序遍历最左路径public class Recursion &#123; public static void traverse(Node&lt;Item&gt; root) &#123; if (root == null) &#123; return; &#125; System.out.println(root.item); traverse(root.left); &#125;&#125;// 循环式二叉树中先序遍历最左路径public class Iteration &#123; public static void traverse(Node&lt;Item&gt; root) &#123; while (root != null) &#123; System.out.println(root.item); root = root.left; &#125; &#125;&#125;// 递归式二叉树后序遍历最左路径public class Recursion &#123; public static void traverse(Node&lt;Item&gt; root) &#123; if (root == null) &#123; return; &#125; traverse(root.left); System.out.println(root.item); &#125;&#125;// 循环式二叉树中后序遍历最左路径public class Iteration &#123; public static void traverse(Node&lt;Item&gt; root) &#123; Stack&lt;Node&lt;Item&gt;&gt; stack = new Stack(); for (Node&lt;Item&gt; node = root; node != null; node = node.left) &#123; stack.push(node); &#125; while (!stack.isEmpty()) &#123; Node&lt;Item&gt; node = stack.pop(); System.out.println(node); &#125; &#125;&#125; 我们可以看到，在这个例子中，递归函数的调用过程仍然单调，同样也实在连续向上返回的过程中用到了参数，但为什么这个例子中就要用到栈呢？仔细观察，我们可以发现，上一个例子中我们作的操作比较特殊，这个操作是对一个整数的加法，而对整数的加法是一个累计的操作，我们只关心这个累计而来的结果，而不关心他是从第一个累加到最后一个还是从最后一个累加到第一个，所以在改写为循环时，通过把这些本该在第一次循环完之后再做的累加操作直接放在第一次循环中执行，就可以在不影响结果的情况下消除栈的使用。而在这个例子中，对二叉树节点的遍历操作，遍历的顺序也是影响结果的因素之一，所以对于后序遍历，我们必需要用到栈。 说到这里，我们再来回顾一下刚才用到常数的例子，无论是对于常数的累加操作，还是遍历操作，顺序都不会对结果造成任何影响，所以我们可以在改写为循环是消除掉对栈的使用。 ¶ 结论 递归调用过程不单调 -&gt; 改写为循环时需要用到栈（第二类递归） 递归调用过程单调 向上返回过程中没有用到参数 -&gt; 改写为循环时不需要用到栈（第一类递归） 向上返回过程中用到了参数 递归调用过程中参数的使用顺序对结果无影响 -&gt; 改写为循环时不需要用到栈（第一类递归） 递归调用过程中参数的使用顺序对结果有影响 -&gt; 改成为循环时需要用到栈（第二类递归） 由于作者水平所限，并不能从数学的角度严格证明上面的结论。因此上面的结论只是基于作者自己的观察作出的总结，因此可能不够完备，甚至错误。 本文的目的在于尝试提供一种相对简单的判别方法用于在将一个递归函数真正改写为循环之前判断其需不需要栈的辅助。 如果你发现了文章中的问题，或者有更好的思路，记得在下方评论哦。😊]]></content>
      <categories>
        <category>编程</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，世界]]></title>
    <url>%2Fzh%2Fposts%2FHello-World%2F</url>
    <content type="text"><![CDATA[你好，世界 这是我的个人博客。 主要分享对于技术学习和思考，但不局限于此。 坚持原创，不定时更新。 1234567// Javaclass HelloWorld &#123; public static void main() &#123; System.out.println("Hello World!"); &#125;&#125; 1234567// C#include "stdio.h"int main() &#123; printf("Hello World!\n"); return 0;&#125; 1234567// C++#include "iostream"int main() &#123; std::cout &lt;&lt; "Hello World!" &lt;&lt; std::endl; return 0;&#125; Hello World! Hello World! Hello World! Hello World! Hello World! Hello World!]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fzh%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[热爱计算机，热爱互联网，热爱人工智能。 极客，完美主义者，兴趣和好奇心驱动。 保持饥饿，保持愚蠢。]]></content>
  </entry>
  <entry>
    <title><![CDATA[书籍]]></title>
    <url>%2Fzh%2Fbooks%2Findex.html</url>
    <content type="text"><![CDATA[¶ 基础 程序设计语言 《C 程序设计语言》（The C Programming Language），作者：Brian Kernighan，Dennis Ritchie 《Java 编程思想》（Thinking in Java），作者：Bruce Eckel 《C++ Primer》，作者：Stanley B. Lippman，Josée Lajoie，Barbara E. Moo 算法与数据结构 《算法》（Algorithms），作者：Robert Sedgewick，Kevin Wayne 《算法导论》（Introduction to Algorithms），作者：Thomas H. Cormen，Charles E. Leiserson，Ronald L. Rivest，Clifford Stein 《算法分析导论》（An Introduction to the Analysis of Algorithms），作者：Robert Sedgewick, Philippe Flajolet 数据库 《数据库系统：全书》（Database Systems: The Complete Book），作者：Hector Garcia-Molina，Jeff Ullman，Jennifer Widom 《高性能 MySQL》（High Performance MySQL: Optimization, Backups, and Replication），作者：Baron Schwartz，Peter Zaitsev，Vadim Tkachenko 《MySQL 技术内幕：InnoDB 存储引擎》，作者：姜承尧 《Redis 设计与实现》，作者：黄健宏 计算机网络 《计算机网络：自顶向下方法》（Computer Networking: A Top-Down Approach），作者：James F. Kurose，Keith W. Ross 《TCP/IP 详解 卷1：协议》(TCP/IP Illustrated, Volume 1: The Protocols)，作者：W. Richard Stevens 《TCP/IP 详解 卷2：实现》(TCP/IP Illustrated, Volume 2: The Implementation)，作者：W. Richard Stevens 《TCP/IP 详解 卷3：TCP 事务协议、HTTP、NNTP 和 UNIX 域协议》（ TCP/IP Illustrated, Vol. 3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols），作者：W. Richard Stevens 《UNIX 网络编程 卷1：套接字联网 API》（Unix Network Programming, Volume 1: The Sockets Networking API），作者：W. Richard Stevens，Bill Fenner，Andrew M. Rudof 《UNIX 网络编程 卷2：进程间通信》（UNIX Network Programming, Volume 2: Interprocess Communications），作者：W. Richard Stevens 操作系统 《现代操作系统》（Modern Operating Systems），作者：Andrew S. Tanenbaum 《UNIX 环境高级编程》（Advanced Programming in the UNIX Environment），作者：W. Richard Stevens，Stephen A. Rago 计算机体系结构 《计算机体系结构：量化研究方法》（Computer Architecture: A Quantitative Approach），作者：John L. Hennessy，David A. Patterson 《计算机组成与设计：硬件、软件接口》（Computer Organization and Design: The Hardware/Software Interface），作者：David A. Patterson，John L. Hennessy 编译原理 《编译原理》（Compilers: Principles, Techniques, and Tools），作者：Alfred V. Aho，Monica S. Lam，Ravi Sethi，Jeffrey D. Ullman 计算机科学 《深入理解计算机系统》（Computer Systems: A Programmer’s Perspective），作者：Randal E. Bryant，David R. O’Hallaron ¶ 进阶 并发编程 《Java 并发编程实战》（Java Concurrency in Practice），作者：Brian Goetz，Tim Peierls，Joshua Bloch，Joseph Bowbeer，David Holmes，Doug Lea 虚拟机 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》，作者：周志明 分布式系统 机器学习 《机器学习》，作者：周志华 《统计学习方法》，作者：李航 ¶ 兴趣]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fzh%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[课程]]></title>
    <url>%2Fzh%2Fcourses%2Findex.html</url>
    <content type="text"><![CDATA[¶ 基础 算法与数据结构 Algorithms, Part I 导师：Robert Sedgewick、Kevin Wayne 机构：Princeton University 平台：Coursera Algorithms, Part II 导师：Robert Sedgewick、Kevin Wayne 机构：Princeton University 平台：Coursera 6.006: Introduction to Algorithms 导师：Erik Demaine，Srinivas Devadas 机构：MIT 平台：MIT OpenCourseWare 6.046J: Design and Analysis of Algorithms 导师：Erik Demaine、Srinivas Devadas、Nancy Lynch 机构：MIT 平台：MIT OpenCourseWare Analysis of Algorithms 导师：Robert Sedgewick 机构：Princeton University 平台：Coursera 数据库 Databases Mini-courses &amp; Introduction to Databases 导师：Jennifer Widom 机构：Stanford University 平台：Stanford Lagunita 计算机网络 Introduction to Computer Networking 导师：Philip Levis、Nick McKeown 机构：Stanford University 平台：Stanford Lagunita 操作系统 6.828: Operating System Engineering 导师：Adam Belay、Frans Kaashoek 机构：MIT 平台：MIT 计算机体系结构 Computer Architecture 导师：David Wentzlaff 机构：Princeton University 平台：Coursera 编译原理 Compilers 导师：Alex Aiken 机构：Stanford University 平台：Stanford Lagunita ¶ 进阶 分布式系统 6.824: Distributed Systems 导师：Robert Morris、Malte Schwarzkopf 机构：MIT 平台：MIT 机器学习 Machine Learning 导师：Andrew Ng 机构：Stanford University 平台：Coursera Deep Learning Specialization 导师：Andrew Ng 机构：deeplearning.ai 平台：Coursera CS231n: Convolutional Neural Networks for Visual Recognition, 课程视频 导师：Fei-Fei Li、Justin Johnson、Serena Yeung 机构：Stanford University 平台：Stanford University CS224n: Natural Language Processing, 课程视频 导师：Chris Manning 机构：Stanford University 平台：Stanford University CS 294-112 Deep Reinforcement Learning 导师：Sergey Levine 机构：UC Berkeley 平台：UC Berkeley 数学 Convex Optimization 导师：Stephen Boyd、Henryk Blasinski、Neal Parikh、Ernest Ryu、Madeleine Udell 机构：Stanford University 平台：Stanford Lagunita Statistical Learning 导师：Trevor Hastie、Rob Tibshirani 机构：Stanford University 平台：Stanford Lagunita ¶ 兴趣 程序设计语言 Programming Languages, A, B, C 导师：Dan Grossman 机构：University of Washington 平台：Coursera]]></content>
  </entry>
  <entry>
    <title><![CDATA[论文]]></title>
    <url>%2Fzh%2Fpapers%2Findex.html</url>
    <content type="text"><![CDATA[¶ 算法 Left-Leaning Red-Black Trees 作者：Robert Sedgewick ¶ 分布式系统 Paxos Made Simple 作者：Leslie Lamport Fast Paxos 作者：Leslie Lamport Raft ¶ 机器学习 YOLO]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Fzh%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
